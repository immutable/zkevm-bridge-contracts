"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxelarQueryAPI = void 0;
const utils_1 = require("ethers/lib/utils");
const assets_1 = require("../assets");
const constants_1 = require("../constants");
const services_1 = require("../services");
const contract_1 = require("./TransactionRecoveryApi/constants/contract");
const AxelarQueryClient_1 = require("./AxelarQueryClient");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const query_1 = require("@axelar-network/axelarjs-types/axelar/nexus/v1beta1/query");
const utils_2 = require("../utils");
const chains_1 = require("../chains");
const s3_1 = __importDefault(require("./TransactionRecoveryApi/constants/s3"));
const ethers_1 = require("ethers");
class AxelarQueryAPI {
    constructor(config) {
        /**
         * Initialize the query client if it hasn't been initialized yet
         */
        this.initQueryClientIfNeeded = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.axelarQueryClient) {
                this.axelarQueryClient = yield AxelarQueryClient_1.AxelarQueryClient.initOrGetAxelarQueryClient({
                    environment: this.environment,
                    axelarRpcUrl: this.axelarRpcUrl,
                });
            }
        });
        const { axelarLcdUrl, axelarRpcUrl, environment } = config;
        const links = (0, constants_1.getConfigs)(environment);
        this.axelarRpcUrl = axelarRpcUrl || links.axelarRpcUrl;
        this.axelarLcdUrl = axelarLcdUrl || links.axelarLcdUrl;
        this.axelarGMPServiceUrl = links.axelarGMPApiUrl;
        this.environment = environment;
        this.lcdApi = new services_1.RestService(this.axelarLcdUrl);
        this.rpcApi = new services_1.RestService(this.axelarRpcUrl);
        this.axelarGMPServiceApi = new services_1.RestService(this.axelarGMPServiceUrl);
        this._initializeAssets();
    }
    _initializeAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            this.allAssets = yield (0, assets_1.loadAssets)({ environment: this.environment });
        });
    }
    /**
     * Gets the fee for a chain and asset
     * example testnet query: https://axelartest-lcd.quickapi.com/axelar/nexus/v1beta1/fee?chain=ethereum&asset=uusd
     * @param chainId
     * @param assetDenom
     * @returns
     */
    getFeeForChainAndAsset(chainId, assetDenom) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([chainId], this.environment);
            yield this.initQueryClientIfNeeded();
            return this.axelarQueryClient.nexus.FeeInfo({
                chain: chainId,
                asset: yield this._convertAssetDenom(assetDenom),
            });
        });
    }
    getEVMEvent(sourceChainId, srcTxHash, srcEventId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([sourceChainId], this.environment);
            yield this.initQueryClientIfNeeded();
            return this.axelarQueryClient.evm
                .Event({
                chain: sourceChainId,
                eventId: `${srcTxHash}-${srcEventId}`,
            })
                .catch(() => undefined);
        });
    }
    getConfirmationHeight(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([chain], this.environment);
            yield this.initQueryClientIfNeeded();
            return this.axelarQueryClient.evm.ConfirmationHeight({ chain });
        });
    }
    /**
     * Gest the transfer fee for a given transaction
     * example testnet query: "https://axelartest-lcd.quickapi.com/axelar/nexus/v1beta1/transfer_fee?source_chain=ethereum&destination_chain=terra&amount=100000000uusd"
     * @param sourceChainId
     * @param destinationChainId
     * @param assetDenom
     * @param amountInDenom
     * @returns
     */
    getTransferFee(sourceChainId, destinationChainId, assetDenom, amountInDenom) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([sourceChainId, destinationChainId], this.environment);
            yield this.initQueryClientIfNeeded();
            return this.axelarQueryClient.nexus.TransferFee({
                sourceChain: sourceChainId,
                destinationChain: destinationChainId,
                amount: `${amountInDenom.toString()}${yield this._convertAssetDenom(assetDenom)}`,
            });
        });
    }
    /**
     * Gets the gas price for a destination chain to be paid to the gas receiver on a source chain
     * example testnet query: https://testnet.api.gmp.axelarscan.io/?method=getGasPrice&destinationChain=ethereum&sourceChain=avalanche&sourceTokenAddress=0x43F4600b552089655645f8c16D86A5a9Fa296bc3&sourceTokenSymbol=UST
     * @param sourceChainId
     * @param destinationChainId
     * @param sourceChainTokenSymbol
     * @returns
     */
    getGasInfo(sourceChainId, destinationChainId, sourceChainTokenSymbol) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([sourceChainId, destinationChainId], this.environment);
            const params = new URLSearchParams({
                method: "getGasPrice",
                destinationChain: destinationChainId,
                sourceChain: sourceChainId,
                sourceTokenSymbol: sourceChainTokenSymbol,
            });
            return this.axelarGMPServiceApi.get(`?${params}`).then((resp) => resp.result);
        });
    }
    /**
     * Gets the base fee in native token wei for a given source and destination chain combination
     * @param sourceChainName
     * @param destinationChainName
     * @param sourceTokenSymbol (optional)
     * @returns base fee in native token in wei, translated into the native gas token of choice
     */
    getNativeGasBaseFee(sourceChainId, destinationChainId, sourceTokenSymbol, symbol, destinationContractAddress, sourceContractAddress, amount, amountInUnits) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([sourceChainId, destinationChainId], this.environment);
            yield this.throwIfInactiveChains([sourceChainId, destinationChainId]);
            const params = {
                method: "getFees",
                destinationChain: destinationChainId,
                sourceChain: sourceChainId,
            };
            if (sourceTokenSymbol)
                params.sourceTokenSymbol = sourceTokenSymbol;
            if (symbol)
                params.symbol = symbol;
            if (destinationContractAddress)
                params.destinationContractAddress = destinationContractAddress;
            if (sourceContractAddress)
                params.sourceContractAddress = sourceContractAddress;
            if (amount) {
                params.amount = amount;
            }
            else if (amountInUnits) {
                params.amountInUnits = amountInUnits;
            }
            return this.axelarGMPServiceApi.post("", params).then((response) => {
                const { source_base_fee_string, source_token, destination_native_token, express_fee_string, express_supported, } = response.result;
                const { decimals: sourceTokenDecimals } = source_token;
                const baseFee = (0, utils_1.parseUnits)(source_base_fee_string, sourceTokenDecimals).toString();
                const expressFee = express_fee_string
                    ? (0, utils_1.parseUnits)(express_fee_string, sourceTokenDecimals).toString()
                    : "0";
                return {
                    baseFee,
                    expressFee,
                    sourceToken: source_token,
                    destToken: {
                        gas_price: destination_native_token.gas_price,
                        gas_price_gwei: parseInt(destination_native_token.gas_price_gwei).toString(),
                        decimals: destination_native_token.decimals,
                    },
                    apiResponse: response,
                    success: true,
                    expressSupported: express_supported,
                };
            });
        });
    }
    /**
     * Calculate estimated gas amount to pay for the gas receiver contract.
     * @param sourceChainId Can be of the EvmChain enum or string. If string, should try to generalize to use the CHAINS constants (e.g. CHAINS.MAINNET.ETHEREUM)
     * @param destinationChainId Can be of the EvmChain enum or string. If string, should try to generalize to use the CHAINS constants (e.g. CHAINS.MAINNET.ETHEREUM)
     * @param sourceChainTokenSymbol
     * @param gasLimit (Optional) An estimated gas amount required to execute `executeWithToken` function. The default value is 700000 which should be sufficient for most transactions.
     * @param gasMultiplier (Optional) A multiplier used to create a buffer above the calculated gas fee, to account for potential slippage throughout tx execution, e.g. 1.1 = 10% buffer. supports up to 3 decimal places
     * @param minGasPrice (Optional) A minimum value, in wei, for the gas price on the destination chain that is used to override the estimated gas price if it falls below this specified value.
     * @param gmpParams (Optional) Additional parameters for GMP transactions, including the ability to see a detailed view of the fee response
     * @returns
     */
    estimateGasFee(sourceChainId, destinationChainId, sourceChainTokenSymbol, gasLimit = contract_1.DEFAULT_ESTIMATED_GAS, gasMultiplier = 1.1, minGasPrice = "0", gmpParams) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, utils_2.throwIfInvalidChainIds)([sourceChainId, destinationChainId], this.environment);
            const response = yield this.getNativeGasBaseFee(sourceChainId, destinationChainId, sourceChainTokenSymbol, gmpParams === null || gmpParams === void 0 ? void 0 : gmpParams.tokenSymbol, gmpParams === null || gmpParams === void 0 ? void 0 : gmpParams.destinationContractAddress, gmpParams === null || gmpParams === void 0 ? void 0 : gmpParams.sourceContractAddress, gmpParams === null || gmpParams === void 0 ? void 0 : gmpParams.transferAmount, gmpParams === null || gmpParams === void 0 ? void 0 : gmpParams.transferAmountInUnits);
            const { baseFee, expressFee, sourceToken, destToken, apiResponse, success, expressSupported } = response;
            if (!success || !baseFee || !sourceToken) {
                throw new Error("Failed to estimate gas fee");
            }
            const destGasFeeWei = (0, utils_1.parseUnits)((gasLimit * Number(destToken.gas_price)).toFixed(destToken.decimals), destToken.decimals);
            const minDestGasFeeWei = ethers_1.BigNumber.from(gasLimit).mul(minGasPrice); //minGasPrice already provided by the user in wei
            const srcGasFeeWei = (0, utils_1.parseUnits)((gasLimit * Number(sourceToken.gas_price)).toFixed(sourceToken.decimals), sourceToken.decimals);
            const executionFee = destGasFeeWei.gt(minDestGasFeeWei)
                ? srcGasFeeWei
                : srcGasFeeWei.mul(minDestGasFeeWei).div(destGasFeeWei);
            const executionFeeWithMultiplier = gasMultiplier > 1 ? executionFee.mul(gasMultiplier * 10000).div(10000) : executionFee;
            return (gmpParams === null || gmpParams === void 0 ? void 0 : gmpParams.showDetailedFees)
                ? {
                    baseFee,
                    expressFee,
                    executionFee: executionFee.toString(),
                    executionFeeWithMultiplier: executionFeeWithMultiplier.toString(),
                    gasLimit,
                    gasMultiplier,
                    minGasPrice: minGasPrice === "0" ? "NA" : minGasPrice,
                    apiResponse,
                    isExpressSupported: expressSupported,
                }
                : executionFeeWithMultiplier.add(baseFee).toString();
        });
    }
    /**
     * Get the denom for an asset given its symbol on a chain
     * @param symbol
     * @param chainName
     * @returns
     */
    getDenomFromSymbol(symbol, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((ac) => {
                var _a, _b;
                return ((_b = (_a = ac.chain_aliases[chainName]) === null || _a === void 0 ? void 0 : _a.assetSymbol) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === (symbol === null || symbol === void 0 ? void 0 : symbol.toLowerCase()) &&
                    !ac.is_gas_token;
            });
            if (!assetConfig)
                return null;
            return assetConfig.common_key[this.environment];
        });
    }
    /**
     * Get the symbol for an asset on a given chain given its denom
     * @param denom
     * @param chainName
     * @returns
     */
    getSymbolFromDenom(denom, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((ac) => ac.common_key[this.environment] === denom && !ac.is_gas_token);
            if (!assetConfig)
                return null;
            return assetConfig.chain_aliases[chainName].assetSymbol;
        });
    }
    /**
     * Get the asset config for an asset on a given chain given its denom
     * @param denom
     * @param chainName
     * @returns asset config
     */
    getAssetConfigFromDenom(denom, chainName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((ac) => ac.common_key[this.environment] === denom && !ac.is_gas_token);
            if (!assetConfig)
                return null;
            const result = assetConfig.chain_aliases[chainName];
            if (!result)
                return null;
            result.decimals = assetConfig.decimals;
            result.common_key = assetConfig.common_key[this.environment];
            return result;
        });
    }
    /**
     * Get the contract address from the chainId and the contractKey
     * @param chainId - the chainId of the chain
     * @param contractKey - the key of the contract in the config file.
     * A valid contractKey can be found here https://github.com/axelarnetwork/chains/blob/790f08350e792e27412ded6721c13ce78267fd72/testnet-config.json#L1951-L1954 e.g. ("gas_service", "deposit_service", "default_refund_collector")
     * @returns the contract address
     */
    getContractAddressFromConfig(chainId, contractKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const chains = yield (0, chains_1.loadChains)({ environment: this.environment });
            const selectedChain = chains.find((chain) => chain.id.toLowerCase() === chainId.toLowerCase());
            if (!selectedChain)
                throw `getContractAddressFromConfig() ${chainId} not found`;
            return yield (0, cross_fetch_1.default)(s3_1.default[this.environment])
                .then((res) => res.json())
                .then((body) => body.assets.network[chainId.toLowerCase()][contractKey])
                .catch(() => undefined);
        });
    }
    /**
     * Get a list of active chains.
     * @returns an array of active chains
     */
    getActiveChains() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initQueryClientIfNeeded();
            return this.axelarQueryClient.nexus
                .Chains({ status: query_1.ChainStatus.CHAIN_STATUS_ACTIVATED })
                .then((resp) => resp.chains);
        });
    }
    /**
     * Check if a chain is active.
     * @param chainId the chain id to check
     * @returns true if the chain is active, false otherwise
     */
    isChainActive(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getActiveChains()
                .then((chains) => chains.map((chain) => chain.toLowerCase()))
                .then((chains) => chains.includes(chainId.toLowerCase()));
        });
    }
    /**
     * Throw an error if any chain in the list is inactive.
     * @param chainIds A list of chainIds to check
     */
    throwIfInactiveChains(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Promise.all(chainIds.map((chainId) => this.isChainActive(chainId)));
            for (let i = 0; i < chainIds.length; i++) {
                if (!results[i]) {
                    throw new Error(`Chain ${chainIds[i]} is not active. Please check the list of active chains using the getActiveChains() method.`);
                }
            }
        });
    }
    /**
     * Check if a chain is active.
     * @param fromChainId source chain id
     * @param toChainId destination chain id
     * @param denom denom of asset (e.g. for USDC, uusdc)
     * @param proportionOfTotalLimitPerTransfer (optional) proportion of total limit you would like to limit users, e.g. for 25% of total, use 4
     * @returns true if the chain is active, false otherwise
     */
    getTransferLimit({ fromChainId, toChainId, denom, proportionOfTotalLimitPerTransfer = 4, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const fromChainNexusResponse = yield this.getTransferLimitNexusQuery({
                chainId: fromChainId,
                denom,
            });
            const toChainNexusResponse = yield this.getTransferLimitNexusQuery({
                chainId: toChainId,
                denom,
            });
            try {
                const { limit: fromChainLimit } = fromChainNexusResponse;
                const { limit: toChainLimit } = toChainNexusResponse;
                if (!fromChainLimit && !toChainLimit)
                    throw new Error(`could not fetch transfer limit for transfer from ${fromChainId} to ${toChainId} for ${denom}`);
                let min;
                if (fromChainLimit && toChainLimit) {
                    const fromBigNum = ethers_1.BigNumber.from(fromChainLimit);
                    const toBigNum = ethers_1.BigNumber.from(toChainLimit);
                    min = fromBigNum.lt(toBigNum) ? fromBigNum : toBigNum;
                }
                else {
                    min = ethers_1.BigNumber.from(fromChainLimit || toChainLimit);
                }
                return min.div(proportionOfTotalLimitPerTransfer).toString();
            }
            catch (e) {
                return "";
            }
        });
    }
    getTransferLimitNexusQuery({ chainId, denom, }) {
        return __awaiter(this, void 0, void 0, function* () {
            // verify chain params
            yield (0, utils_2.throwIfInvalidChainIds)([chainId], this.environment);
            const chains = yield (0, chains_1.loadChains)({ environment: this.environment });
            const chain = chains.find((c) => c.id === chainId);
            if (!chain)
                throw `Chain ${chainId} not found`;
            const api = yield AxelarQueryClient_1.AxelarQueryClient.initOrGetAxelarQueryClient({
                environment: this.environment,
            });
            const asset = yield this._convertAssetDenom(denom);
            try {
                // the "limit" response to the TransferRateLimit RPC query is of type Uint8Array, so need to decode it
                const res = yield api.nexus.TransferRateLimit({ chain: chainId, asset });
                const { transferRateLimit } = res;
                if (!transferRateLimit ||
                    !transferRateLimit.limit ||
                    !transferRateLimit.incoming ||
                    !transferRateLimit.outgoing)
                    throw new Error(`did not receive a valid response to ${chainId} / ${denom} transfer query`);
                const { limit, incoming, outgoing } = transferRateLimit;
                return {
                    limit: new TextDecoder("utf-8").decode(new Uint8Array(limit)),
                    outgoing: new TextDecoder("utf-8").decode(new Uint8Array(outgoing)),
                    incoming: new TextDecoder("utf-8").decode(new Uint8Array(incoming)),
                };
            }
            catch (e) {
                return { limit: "", outgoing: "", incoming: "" };
            }
        });
    }
    _convertAssetDenom(denom) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.allAssets)
                yield this._initializeAssets();
            const assetConfig = this.allAssets.find((asset) => asset.common_key[this.environment] === denom.toLowerCase());
            if (!assetConfig)
                throw `Asset ${denom} not found`;
            return assetConfig.wrapped_erc20 ? assetConfig.wrapped_erc20 : denom;
        });
    }
}
exports.AxelarQueryAPI = AxelarQueryAPI;
//# sourceMappingURL=AxelarQueryAPI.js.map