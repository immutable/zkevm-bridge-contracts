"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosNetwork = void 0;
const aptos_1 = require("aptos");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const sha3_1 = require("@noble/hashes/sha3");
const utils_1 = require("./utils");
class AptosNetwork extends aptos_1.AptosClient {
    constructor(nodeUrl) {
        super(nodeUrl);
        this.getLatestEventSequence = (events) => {
            if (events.length == 0)
                return null;
            return parseInt(events[events.length - 1].sequence_number);
        };
        // WARNING: should not use the same account for production!
        this.owner = new aptos_1.AptosAccount(new aptos_1.HexString('0x2a6f6988be264385fbfd552b8aa93451c6aac25d85786dd473fe7159f9320425').toUint8Array());
        this.contractCallSequence = -1;
        this.payContractCallSequence = -1;
        this.resourceAddress = '0xe2a20d8c426eb04d882e20e78399b24123905d9f1adf95a292832805965e263a';
        this.isGatewayDeployed().then((result) => {
            if (result) {
                this.queryContractCallEvents().then((events) => {
                    if (events)
                        this.updateContractCallSequence(events);
                });
                this.queryPayGasContractCallEvents().then((events) => {
                    if (events)
                        this.updatePayGasContractCallSequence(events);
                });
            }
        });
    }
    isGatewayDeployed() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resources = yield this.getAccountResources(this.owner.address());
                const resource_accounts = resources.find((resource) => resource.type == '0x1::resource_account::Container');
                if (!resource_accounts)
                    return false;
                const data = resource_accounts.data;
                const gateway = data.store.data.find((entry) => entry.key == this.resourceAddress);
                return gateway != null;
            }
            catch (e) {
                return false;
            }
        });
    }
    deploy(modulePath, compiledModules, seed = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageMetadata = fs_1.default.readFileSync(path_1.default.join(modulePath, 'package-metadata.bcs'));
            const moduleDatas = compiledModules.map((module) => {
                return fs_1.default.readFileSync(path_1.default.join(modulePath, 'bytecode_modules', module));
            });
            let txHash;
            if (seed) {
                const data = yield this.generateTransaction(this.owner.address(), {
                    function: `0x1::resource_account::create_resource_account_and_publish_package`,
                    type_arguments: [],
                    arguments: [aptos_1.HexString.ensure(seed).toUint8Array(), packageMetadata, moduleDatas],
                });
                const bcsTxn = yield this.signTransaction(this.owner, data);
                txHash = (yield this.submitTransaction(bcsTxn)).hash;
            }
            else {
                txHash = yield this.publishPackage(this.owner, new aptos_1.HexString(packageMetadata.toString('hex')).toUint8Array(), moduleDatas.map((moduleData) => new aptos_1.TxnBuilderTypes.Module(new aptos_1.HexString(moduleData.toString('hex')).toUint8Array())));
            }
            const tx = yield this.waitForTransactionWithResult(txHash);
            if (!tx.success) {
                throw new Error(`Error: ${tx.vm_status}`);
            }
            return tx;
        });
    }
    getOwnerBalance() {
        return new aptos_1.CoinClient(this).checkBalance(this.owner);
    }
    deployAxelarFrameworkModules() {
        const modulePath = (0, utils_1.findAxelarFramework)(__dirname);
        return this.deploy(modulePath, ['axelar_gas_service.mv', 'address_utils.mv', 'gateway.mv'], '0x1234');
    }
    updateContractCallSequence(events) {
        const lastSequence = this.getLatestEventSequence(events);
        if (lastSequence !== null) {
            this.contractCallSequence = lastSequence;
        }
    }
    updatePayGasContractCallSequence(events) {
        const lastSequence = this.getLatestEventSequence(events);
        if (lastSequence !== null) {
            this.payContractCallSequence = lastSequence;
        }
    }
    queryContractCallEvents(options) {
        const _options = options || { start: this.contractCallSequence === -1 ? 0 : this.contractCallSequence + 1, limit: 100 };
        return this.getEventsByEventHandle(this.resourceAddress, `${this.resourceAddress}::gateway::OutgoingContractCallsState`, 'events', _options);
    }
    queryPayGasContractCallEvents(options) {
        const _options = options || { start: this.payContractCallSequence === -1 ? 0 : this.payContractCallSequence + 1, limit: 100 };
        return this.getEventsByEventHandle(this.resourceAddress, `${this.resourceAddress}::axelar_gas_service::GasServiceEventStore`, 'native_gas_paid_for_contract_call_events', _options);
    }
    approveContractCall(commandId, sourceChain, sourceAddress, destinationAddress, payloadHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.submitTransactionAndWait(this.owner.address(), {
                function: `${this.resourceAddress}::gateway::approve_contract_call`,
                type_arguments: [],
                arguments: [commandId, sourceChain, sourceAddress, destinationAddress, payloadHash],
            });
            return {
                hash: tx.hash,
                success: tx.success,
                vmStatus: tx.vm_status,
            };
        });
    }
    execute(commandId, destinationAddress, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.submitTransactionAndWait(this.owner.address(), {
                function: `${destinationAddress}::execute`,
                type_arguments: [],
                arguments: [commandId, payload],
            });
            return {
                hash: tx.hash,
                success: tx.success,
                vmStatus: tx.vm_status,
            };
        });
    }
    submitTransactionAndWait(from, txData) {
        return __awaiter(this, void 0, void 0, function* () {
            const rawTx = yield this.generateTransaction(from, txData);
            const signedTx = yield this.signTransaction(this.owner, rawTx);
            const aptosTx = yield this.submitTransaction(signedTx);
            return this.waitForTransactionWithResult(aptosTx.hash);
        });
    }
    static getResourceAccountAddress(sourceAddress, seed) {
        seed = aptos_1.HexString.ensure(seed);
        const source = aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(sourceAddress));
        const bytes = new Uint8Array([...source, ...seed.toUint8Array(), 255]);
        const hash = sha3_1.sha3_256.create();
        hash.update(bytes);
        return aptos_1.HexString.fromUint8Array(hash.digest());
    }
}
exports.AptosNetwork = AptosNetwork;
//# sourceMappingURL=AptosNetwork.js.map