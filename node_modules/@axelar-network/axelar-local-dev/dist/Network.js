'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteNetwork = exports.Network = exports.networks = void 0;
const http_1 = __importDefault(require("http"));
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
const utils_2 = require("./utils");
const contracts_1 = require("./contracts");
const AxelarGateway__factory_1 = require("./types/factories/@axelar-network/axelar-cgp-solidity/contracts/AxelarGateway__factory");
const AxelarGasService__factory_1 = require("./types/factories/@axelar-network/axelar-cgp-solidity/contracts/gas-service/AxelarGasService__factory");
const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';
const { defaultAbiCoder, arrayify, keccak256, toUtf8Bytes } = ethers_1.ethers.utils;
exports.networks = [];
/*
 * The Network class
 */
class Network {
    constructor(networkish = {}) {
        this.name = networkish.name;
        this.chainId = networkish.chainId;
        this.provider = networkish.provider;
        this.userWallets = networkish.userWallets;
        this.ownerWallet = networkish.ownerWallet;
        this.operatorWallet = networkish.operatorWallet;
        this.relayerWallet = networkish.relayerWallet;
        this.adminWallets = networkish.adminWallets;
        this.threshold = networkish.threshold;
        this.lastRelayedBlock = networkish.lastRelayedBlock;
        this.lastExpressedBlock = networkish.lastExpressedBlock;
        this.gateway = networkish.gateway;
        this.gasService = networkish.gasService;
        this.constAddressDeployer = networkish.constAddressDeployer;
        this.create3Deployer = networkish.create3Deployer;
        this.isRemote = networkish.isRemote;
        this.url = networkish.url;
        this.tokens = networkish.tokens;
    }
    deployGateway() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.logger.log(`Deploying the Axelar Gateway for ${this.name}... `);
            const params = arrayify(defaultAbiCoder.encode(['address[]', 'uint8', 'bytes'], [this.adminWallets.map((wallet) => wallet.address), this.threshold, '0x']));
            const auth = yield (0, utils_2.deployContract)(this.ownerWallet, contracts_1.Auth, [
                [defaultAbiCoder.encode(['address[]', 'uint256[]', 'uint256'], [[this.operatorWallet.address], [1], 1])],
            ]);
            const tokenDeployer = yield (0, utils_2.deployContract)(this.ownerWallet, contracts_1.TokenDeployer);
            const gateway = yield (0, utils_2.deployContract)(this.ownerWallet, AxelarGateway__factory_1.AxelarGateway__factory, [auth.address, tokenDeployer.address]);
            const proxy = yield (0, utils_2.deployContract)(this.ownerWallet, contracts_1.AxelarGatewayProxy, [gateway.address, params]);
            yield (yield auth.transferOwnership(proxy.address)).wait();
            this.gateway = AxelarGateway__factory_1.AxelarGateway__factory.connect(proxy.address, this.provider);
            utils_1.logger.log(`Deployed at ${this.gateway.address}`);
            return this.gateway;
        });
    }
    _upgradeGateway(oldAdminAddresses = undefined, oldThreshold = this.threshold) {
        return __awaiter(this, void 0, void 0, function* () {
            const adminWallets = oldAdminAddresses !== undefined
                ? oldAdminAddresses.map((address) => this.provider.getSigner(address))
                : this.adminWallets;
            utils_1.logger.log(`Upgrading the Axelar Gateway for ${this.name}... `);
            const params = arrayify(defaultAbiCoder.encode(['address[]', 'uint256', 'bytes'], [this.adminWallets.map((wallet) => wallet.address), this.threshold, '0x']));
            const auth = yield (0, utils_2.deployContract)(this.ownerWallet, contracts_1.Auth, [
                [defaultAbiCoder.encode(['address[]', 'uint256[]', 'uint256'], [[this.operatorWallet.address], [1], 1])],
            ]);
            const tokenDeployer = yield (0, utils_2.deployContract)(this.ownerWallet, contracts_1.TokenDeployer);
            const gateway = yield (0, utils_2.deployContract)(this.ownerWallet, AxelarGateway__factory_1.AxelarGateway__factory, [auth.address, tokenDeployer.address]);
            const implementationCode = yield this.provider.getCode(gateway.address);
            const implementationCodeHash = keccak256(implementationCode);
            for (let i = 0; i < oldThreshold; i++) {
                yield (yield this.ownerWallet.sendTransaction({ to: adminWallets[i]._address, value: BigInt(1e18) })).wait();
                yield (yield this.gateway.connect(adminWallets[i]).upgrade(gateway.address, implementationCodeHash, params)).wait();
            }
            yield (yield auth.transferOwnership(this.gateway.address)).wait();
            utils_1.logger.log(`Upgraded ${this.gateway.address}`);
            return this.gateway;
        });
    }
    deployGasReceiver() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.logger.log(`Deploying the Axelar Gas Receiver for ${this.name}... `);
            const gasService = yield (0, utils_2.deployContract)(this.ownerWallet, AxelarGasService__factory_1.AxelarGasService__factory, [this.ownerWallet.address]);
            const gasReceiverProxy = yield (0, utils_2.deployContract)(this.ownerWallet, contracts_1.AxelarGasReceiverProxy);
            yield gasReceiverProxy.init(gasService.address, this.ownerWallet.address, '0x');
            this.gasService = AxelarGasService__factory_1.AxelarGasService__factory.connect(gasReceiverProxy.address, this.provider);
            utils_1.logger.log(`Deployed at ${this.gasService.address}`);
            return this.gasService;
        });
    }
    deployConstAddressDeployer() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.logger.log(`Deploying the ConstAddressDeployer for ${this.name}... `);
            const constAddressDeployerDeployerPrivateKey = keccak256(toUtf8Bytes('const-address-deployer-deployer'));
            const deployerWallet = new ethers_1.Wallet(constAddressDeployerDeployerPrivateKey, this.provider);
            yield this.ownerWallet
                .sendTransaction({
                to: deployerWallet.address,
                value: BigInt(1e18),
            })
                .then((tx) => tx.wait());
            const constAddressDeployer = yield (0, utils_2.deployContract)(deployerWallet, contracts_1.ConstAddressDeployer, []);
            this.constAddressDeployer = new ethers_1.Contract(constAddressDeployer.address, contracts_1.ConstAddressDeployer.abi, this.provider);
            utils_1.logger.log(`Deployed at ${this.constAddressDeployer.address}`);
            return this.constAddressDeployer;
        });
    }
    deployCreate3Deployer() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.logger.log(`Deploying the ConstAddressDeployer for ${this.name}... `);
            const create3DeployerPrivateKey = keccak256(toUtf8Bytes('const-address-deployer-deployer'));
            const deployerWallet = new ethers_1.Wallet(create3DeployerPrivateKey, this.provider);
            yield this.ownerWallet
                .sendTransaction({
                to: deployerWallet.address,
                value: BigInt(1e18),
            })
                .then((tx) => tx.wait());
            const create3Deployer = yield (0, utils_2.deployContract)(deployerWallet, contracts_1.Create3Deployer, []);
            this.create3Deployer = new ethers_1.Contract(create3Deployer.address, contracts_1.Create3Deployer.abi, this.provider);
            utils_1.logger.log(`Deployed at ${this.constAddressDeployer.address}`);
            return this.create3Deployer;
        });
    }
    deployToken(name, symbol, decimals, cap, address = ADDRESS_ZERO, alias = symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.logger.log(`Deploying ${name} for ${this.name}... `);
            const data = arrayify(defaultAbiCoder.encode(['uint256', 'bytes32[]', 'string[]', 'bytes[]'], [
                this.chainId,
                [(0, utils_2.getRandomID)()],
                ['deployToken'],
                [
                    defaultAbiCoder.encode(['string', 'string', 'uint8', 'uint256', 'address', 'uint256'], [name, symbol, decimals, cap, address, 0]),
                ],
            ]));
            const signedData = yield (0, utils_2.getSignedExecuteInput)(data, this.operatorWallet);
            yield (yield this.gateway.connect(this.ownerWallet).execute(signedData, { gasLimit: BigInt(8e6) })).wait();
            const tokenAddress = yield this.gateway.tokenAddresses(symbol);
            const tokenContract = new ethers_1.Contract(tokenAddress, contracts_1.BurnableMintableCappedERC20.abi, this.ownerWallet);
            utils_1.logger.log(`Deployed at ${tokenContract.address}`);
            this.tokens[alias] = symbol;
            return tokenContract;
        });
    }
    getTokenContract(alias) {
        return __awaiter(this, void 0, void 0, function* () {
            const symbol = this.tokens[alias];
            const address = yield this.gateway.tokenAddresses(symbol);
            return new ethers_1.Contract(address, contracts_1.BurnableMintableCappedERC20.abi, this.provider);
        });
    }
    giveToken(address, alias, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const symbol = this.tokens[alias] || alias;
            const data = arrayify(defaultAbiCoder.encode(['uint256', 'bytes32[]', 'string[]', 'bytes[]'], [
                this.chainId,
                [(0, utils_2.getRandomID)()],
                ['mintToken'],
                [defaultAbiCoder.encode(['string', 'address', 'uint256'], [symbol, address, amount])],
            ]));
            const signedData = yield (0, utils_2.getSignedExecuteInput)(data, this.operatorWallet);
            yield (yield this.gateway.connect(this.ownerWallet).execute(signedData, { gasLimit: BigInt(8e6) })).wait();
        });
    }
    getInfo() {
        const info = {
            name: this.name,
            chainId: this.chainId,
            userKeys: this.userWallets.map((wallet) => wallet.privateKey),
            ownerKey: this.ownerWallet.privateKey,
            operatorKey: this.operatorWallet.privateKey,
            relayerKey: this.relayerWallet.privateKey,
            adminKeys: this.adminWallets.map((wallet) => wallet.privateKey),
            threshold: this.threshold,
            lastRelayedBlock: this.lastRelayedBlock,
            lastExpressedBlock: this.lastExpressedBlock,
            gatewayAddress: this.gateway.address,
            gasReceiverAddress: this.gasService.address,
            constAddressDeployerAddress: this.constAddressDeployer.address,
            create3DeployerAddress: this.create3Deployer.address,
            tokens: this.tokens,
        };
        return info;
    }
    getCloneInfo() {
        return {
            name: this.name,
            chainId: this.chainId,
            gateway: this.gateway.address,
            gasService: this.gasService.address,
            constAddressDeployer: this.constAddressDeployer.address,
            create3Deployer: this.create3Deployer.address,
            tokens: this.tokens,
        };
    }
}
exports.Network = Network;
class RemoteNetwork extends Network {
    relay() {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => {
                http_1.default.get(this.url + '/relay', (res) => {
                    const { statusCode } = res;
                    if (statusCode !== 200) {
                        reject(null);
                    }
                    res.on('data', (chunk) => { });
                    res.on('end', () => {
                        resolve(null);
                    });
                });
            });
        });
    }
}
exports.RemoteNetwork = RemoteNetwork;
//# sourceMappingURL=Network.js.map