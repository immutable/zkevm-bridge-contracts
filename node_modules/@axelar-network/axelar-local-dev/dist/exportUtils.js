'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.destroyExported = exports.forkAndExport = exports.createAndExport = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
const relay_1 = require("./relay");
const networkUtils_1 = require("./networkUtils");
const info_1 = require("./info");
const EvmRelayer_1 = require("./relay/EvmRelayer");
const axelar_chains_config_1 = require("@axelar-network/axelar-chains-config");
let interval;
const defaultEvmRelayer = new EvmRelayer_1.EvmRelayer();
let relaying = false;
function createAndExport(options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { accountsToFund, afterRelay, callback, chainOutputPath, chains, fundAmount, port, relayInterval, relayers } = options;
        const _options = {
            chainOutputPath: chainOutputPath || './local.json',
            accountsToFund: accountsToFund || [],
            fundAmount: fundAmount || ethers_1.ethers.utils.parseEther('100').toString(),
            chains: chains || ['Moonbeam', 'Avalanche', 'Fantom', 'Ethereum', 'Polygon'],
            port: port || 8500,
            afterRelay: afterRelay || null,
            relayers: relayers || { evm: defaultEvmRelayer },
            callback: callback || null,
            relayInterval: relayInterval || 2000,
        };
        const localChains = [];
        let i = 0;
        for (const name of _options.chains) {
            const chain = yield (0, networkUtils_1.createNetwork)({
                name: name,
                seed: name,
                ganacheOptions: {},
            });
            const testnet = info_1.testnetInfo[name];
            const info = chain.getCloneInfo();
            info.rpc = `http://localhost:${_options.port}/${i}`;
            (info.tokenName = testnet === null || testnet === void 0 ? void 0 : testnet.tokenName), (info.tokenSymbol = testnet === null || testnet === void 0 ? void 0 : testnet.tokenSymbol), localChains.push(info);
            const [user] = chain.userWallets;
            for (const account of _options.accountsToFund) {
                yield user
                    .sendTransaction({
                    to: account,
                    value: _options.fundAmount,
                })
                    .then((tx) => tx.wait());
            }
            if (_options.callback)
                yield _options.callback(chain, info);
            if (Object.keys(chain.tokens).length > 0) {
                // Check if there is a USDC token.
                const alias = Object.keys(chain.tokens).find((alias) => alias.toLowerCase().includes('usdc'));
                // If there is no USDC token, return.
                if (!alias)
                    return;
            }
            i++;
        }
        (0, networkUtils_1.listen)(_options.port);
        interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            if (relaying)
                return;
            relaying = true;
            yield (0, relay_1.relay)(_options.relayers).catch(() => undefined);
            if (options.afterRelay) {
                const evmRelayData = (_a = _options.relayers.evm) === null || _a === void 0 ? void 0 : _a.relayData;
                const nearRelayData = (_b = _options.relayers.near) === null || _b === void 0 ? void 0 : _b.relayData;
                const aptosRelayData = (_c = _options.relayers.aptos) === null || _c === void 0 ? void 0 : _c.relayData;
                const suiRelayData = (_d = _options.relayers.sui) === null || _d === void 0 ? void 0 : _d.relayData;
                evmRelayData && (yield options.afterRelay(evmRelayData));
                nearRelayData && (yield options.afterRelay(nearRelayData));
                aptosRelayData && (yield options.afterRelay(aptosRelayData));
                suiRelayData && (yield options.afterRelay(suiRelayData));
            }
            relaying = false;
        }), _options.relayInterval);
        const evmRelayer = _options.relayers['evm'];
        evmRelayer === null || evmRelayer === void 0 ? void 0 : evmRelayer.subscribeExpressCall();
        (0, utils_1.setJSON)(localChains, _options.chainOutputPath);
    });
}
exports.createAndExport = createAndExport;
function forkAndExport(options = {}) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const _options = {
            chainOutputPath: options.chainOutputPath || './local.json',
            accountsToFund: options.accountsToFund || [],
            fundAmount: options.fundAmount || ethers_1.ethers.utils.parseEther('100').toString(),
            env: options.env || 'mainnet',
            chains: options.chains || ['Moonbeam', 'Avalanche', 'Fantom', 'Ethereum', 'Polygon'],
            port: options.port || 8500,
            relayInterval: options.relayInterval || 2000,
            relayers: options.relayers || { evm: defaultEvmRelayer },
            networkOptions: options.networkOptions,
            callback: options.callback,
            afterRelay: options.afterRelay,
        };
        const chains_local = [];
        if (_options.env != 'mainnet' && _options.env != 'testnet') {
            console.log(`Forking ${_options.env.length} chains from custom data.`);
        }
        const chainsRaw = _options.env == 'mainnet' ? (0, axelar_chains_config_1.getChainArray)('mainnet') : _options.env == 'testnet' ? (0, axelar_chains_config_1.getChainArray)('testnet') : _options.env;
        const chains = ((_a = _options.chains) === null || _a === void 0 ? void 0 : _a.length) == 0
            ? chainsRaw
            : chainsRaw.filter((chain) => { var _a; return ((_a = _options.chains) === null || _a === void 0 ? void 0 : _a.find((name) => name.toLocaleLowerCase() == chain.name.toLocaleLowerCase())) != null; });
        let i = 0;
        for (const chain of chains) {
            const network = yield (0, networkUtils_1.forkNetwork)(chain, _options.networkOptions);
            const info = network.getCloneInfo();
            info.rpc = `http://localhost:${options.port}/${i}`;
            (info.tokenName = chain === null || chain === void 0 ? void 0 : chain.tokenName), (info.tokenSymbol = chain === null || chain === void 0 ? void 0 : chain.tokenSymbol), chains_local.push(info);
            const [user] = network.userWallets;
            for (const account of _options.accountsToFund) {
                yield user
                    .sendTransaction({
                    to: account,
                    value: options.fundAmount,
                })
                    .then((tx) => tx.wait());
            }
            yield ((_b = _options.callback) === null || _b === void 0 ? void 0 : _b.call(_options, network, info));
            i++;
        }
        (0, networkUtils_1.listen)(_options.port);
        interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            const evmRelayer = _options.relayers['evm'];
            if (!evmRelayer)
                return;
            yield evmRelayer.relay();
            if (_options.afterRelay)
                _options.afterRelay(evmRelayer.relayData);
        }), _options.relayInterval);
        const evmRelayer = _options.relayers['evm'];
        evmRelayer === null || evmRelayer === void 0 ? void 0 : evmRelayer.subscribeExpressCall();
        (0, utils_1.setJSON)(chains_local, _options.chainOutputPath);
    });
}
exports.forkAndExport = forkAndExport;
function destroyExported(relayers) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        (0, networkUtils_1.stopAll)();
        if (interval) {
            clearInterval(interval);
        }
        yield (defaultEvmRelayer === null || defaultEvmRelayer === void 0 ? void 0 : defaultEvmRelayer.unsubscribe());
        if (!relayers)
            return;
        yield ((_a = relayers['evm']) === null || _a === void 0 ? void 0 : _a.unsubscribe());
        for (const relayerType in relayers) {
            const relayer = relayers[relayerType];
            if (relayer) {
                relayer.contractCallGasEvents.length = 0;
                relayer.contractCallWithTokenGasEvents.length = 0;
            }
        }
        defaultEvmRelayer.contractCallGasEvents.length = 0;
        defaultEvmRelayer.contractCallWithTokenGasEvents.length = 0;
    });
}
exports.destroyExported = destroyExported;
//# sourceMappingURL=exportUtils.js.map